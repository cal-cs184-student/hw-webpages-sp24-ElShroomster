<html>
	<div class="container">
  		<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw1/radical_rasterizers.png" alt="Radical Rasterizers">
	</div>
	<head>
 		<link rel="stylesheet" href="styling.css">
		<Title>Homework 1 - Rasterizer</Title>
	</head>
	<body>
		<h2>Homework 1 - <b>Rasterizer</b></h2>
		<h5 style="color: gray">by Sriram Srivatsan &#40;sriram.srivatsan &#40;at&#41; berkeley.edu&#41; and Jaron Erba &#40;jaronerba &#40;at&#41; berkeley.edu&#41;</h5>
		<a style="color: gray", href="https://cal-cs184-student.github.io/hw-webpages-sp24-ElShroomster/">https://cal-cs184-student.github.io/hw-webpages-sp24-ElShroomster/</a>
		
		<h3><b>Single Color Triangles</b></h3>
		<p style="color: white; width: 75%">    To rasterize a triangle, we check a grid pixel by pixel to test whether each point lies within the three triangle vertices. We do this mathematically by creating a normal vector pointing inwards from each of our edges, and testing whether the dot product of a vector between our point and the vertex and the normal vector is greater than zero. Instead of sampling the entire screen space, we limited the number of tests we do per triangle to just the ones inside the bounding box of the triangle. To do this, we simply sampled each pixel between the leftmost and rightmost x-coordinate in our triangle’s vertices, and likewise for the highest and lowest y-coordinate. In this process, we faced two challenges. Firstly, for our algorithm to work, we needed to ensure that the normal vectors actually pointed into the triangle. In order to make this work, we tested the winding order of the vertices using <a href="https://stackoverflow.com/a/1165943" style="display: inline"> this</a> formula. After adjusting our vertices so that they are in counter-clockwise order, we had to sample our pixels. Here lies our second, and final, bug that our code had: bounding boxes. Initially, we made it so that the bounding box would round our minimum and maximum values of x and y, which caused many triangles to not render fully, as shown below:</p>
		<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw1/rounding_error.png" alt="Rounding Error" class="center">
		<p style="color: white; width: 75%">    By addressing these issues, we got basic rasterizing to work! Below is an image of a successful render highlighting a major drawback with this algorithm, aliasing, in basic/test4.svg:</p>
		<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw1/svg4_pixel_inspector.png" alt="svg4 Aliased" class="center">
		<p style="color: white; width: 75%">    <i>Todo: Exta credit</i></p>
		<br>
		<h3><b>Antialiasing by Supersampling</b></h3>
		<p style="color: white; width: 75%">    In order to reduce aliasing such as jaggies and floating pixels, we use supersampling. We set a sample rate and sample multiple evenly spaced points inside each pixel, then average them to get the total color of that pixel. This means that if a triangle has some area inside a pixel but doesn’t go through the center, we can still ensure that the figure gets equal representation. For example, if the triangle goes through the top right corner, that would be approximately 1/9 of the pixel’s area, so we would give that pixel 1/9th of the triangle’s color. Initially, we thought it would be more space efficient to keep our screen space array the same dimensions, and simply average down each pixel as we rasterize each triangle. This sounded like a great idea, but when multiple triangles were slightly in a single pixel, this prevented the final pixel color from incorporating all of the triangles involved. Instead, we got weird bright lines cutting through our images. In the end, we decided to multiply the dimensions of our screen space matrix by the sample rate, then rasterize each triangle in our svg by pretending the screen was simply much larger. To draw the matrix onto the screen, we then averaged down for each pixel. Below is an example of supersampling, using 1, 4, and 16 points inside each pixel, reducing aliasing in the same image represented above: </p>
		<div class="row">
  			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw1/red1x1.png" alt="svg4 Aliased" class="column">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw1/red2x2.png" alt="svg4 Slightly Aliased" class="column">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw1/red4x4.png" alt="svg4 Less Aliased" class="column">
			</div>
		</div>
		<br>
		<p style="color: white; width: 75%">    <i>Todo: Exta credit</i></p>
		<br>
		<h3><b>Transforms</b></h3>
		<br>
		<h3><b>Barycentric Coordinates</b></h3>
		<br>
		<h3><b>Pixel Sampling for Textures</b></h3>
		<br>
		<h3><b>Level Sampling with Mipmaps for Textures</b></h3>
		<br>
		<h3><b>Extra Credit</b></h3>
		<br>
	</body>
</html>
