<html>
	<div class="container">
  		<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/ingeniousilluminators.png" alt="Ingenious Illuminators">
	</div>
	<head>
		<script type="text/javascript" id="MathJax-script" async
  			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
		</script>
		<script>
  			MathJax = {
    				tex: {
      					inlineMath: [['$', '$']]
    				}
  			};
		</script>
 		<link rel="stylesheet" href="styling.css">
		<Title>Homework 3 - Pathtracer</Title>
	</head>
	<body>
		<h2>Homework 3 - <b>Pathtracer</b></h2>
		<center>
		<h5 style="color: #DBDEE1">by Sriram Srivatsan &#40;sriram.srivatsan &#40;at&#41; berkeley.edu&#41; and Jaron Erba &#40;jaronerba &#40;at&#41; berkeley.edu&#41;</h5>
		</center>
		<a style="color: #DBDEE1", href="https://cal-cs184-student.github.io/hw-webpages-sp24-ElShroomster/"> Main Page </a>

		<h3><b>Overview</b></h3>
		<p style="color: #DBDEE1; width: 100%">Hot steamy carrots </p>
		<br>
		
		<h3><b>Part 1: Ray Generation and Scene Intersection </b></h3>
		<p style="color: #DBDEE1; width: 100%">In concept, the ray generation scheme works by generating a ray (or pretty much a vector) from the camera position in world space to a specific point in camera space determined by $(x,y)$. We implement this in generate_ray() by creating a new ray with ray.min_t = nClip, ray.max_t = fClip, and ray.o = camera pos. We are then able to calculate the camera size, and thus calculate the camera relative positions of $x$ and $y$. We can then convert this point to world space, set it to the $d$ value of the ray, and return the ray.</p>
		<p style="color: #DBDEE1; width: 100%">For the randomized ray sampling within a pixel inside of raytrace_pixel(), we use  the get_sample() function to find a random position within the pixel, use generate_ray to create the ray, and then call est_radiance_globabl_illumination() on that pixel. We can then update the pixel and add it to the buffer.</p>
		<p style="color: #DBDEE1; width: 100%">For our triangle intersection, we just used a simple algorithm from the lecture slides. We first calculate $E_1$, $E_2$, $S$, $S_1$, and $S_2$  from the given ray, and then use the equation  $$\frac{1}{S_1 \bullet E_1} \cdot \left(S_2\bullet E_2, S_1\bullet S, S_2\bullet r_d\right)$$ to calculate the intersection. Then, after applying a few checks (namely, checking if the x,y, and z components are in bounds,) we are able to return true. (For intersect(), not has_intersection(), we also add the relevant values to the given intersection.)</p>
		<p style="color: #DBDEE1; width: 100%">For sphere intersection, we used the idea that a ray is determined by $r(t)=o+t\cdot d$. So, from the slides, the intersection of the ray can be found by solving at^2+bt+c-0 where $a$ is the dot product of the ray direction with itself, $b$ is twice the dot product of the ray direction with the vector from the ray origin to the sphere, and $c$ is the squared distance between the ray origin and the sphere center minus the squared radius of the sphere.</p>
		<p style="color: #DBDEE1; width: 100%">Then, we are able to determine if the ray had an intersection with the sphere based on the value of the determinant. Our code implements this quite literally. Additionally, on intersect(), not has_intersection(), we add the intersection time $t$ to the Intersection struct passed into the function.</p>
		<p style="color: #DBDEE1; width: 100%">Now we can render some pretty images as can be seen below:</p>
		<div class="row">
  			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task1/task1/lucy.png" alt="0">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task1/task1/cow.png" alt="1">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task1/task1/spheres.png" alt="2">
			</div>
		</div>
		<br>
		<br>
		
		
		<h3><b>Part 2: Bounding Volume Hierarchy</b></h3>
		<p style="color: #DBDEE1; width: 100%">The teapot rendered after the task can be seen below:</p>
		
		<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/teapottask2.png" alt="teapot_basic">
		<br>
		<br>
		
		<h3><b>Part 3: Direct Illumination</b></h3>
		<p style="color: #DBDEE1; width: 100%">hi</p>
		<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/flat_and_phong.png" alt="flat_and_phong_teapot">
		<br>
		<br>
		
		<h3><b>Part 4: Global Illumination</b></h3>
		<p style="color: #DBDEE1; width: 100%">hi</p>
		<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/edgeflipboth.png" alt="quadball_normal_and_flipped">
		<br>
		<br>
		
		<h3><b>Part 5: Adaptive Sampling</b></h3>
		<p style="color: #DBDEE1; width: 100%">Below are images of cow.dae before and after some edge splits and edge splits and flips: </p>
		<div class="row">
			<div class="column">
			  <img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/cow_normal.png" alt="cow_normal">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/cow_split.png" alt="cow_split">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/cow_split_and_flipped.png" alt="cow_split_and_flipped">
			</div>
		</div>
		<br>
		
		<h3><b>Part 6: Extra Credit</b></h3>
		<p style="color: #DBDEE1; width: 100%">The teapot rendered after the task can be seen below:</p>
		<br>
		<br>
	</body>
</html>
