<html>
	<div class="container">
  		<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/ingeniousilluminators.png" alt="Ingenious Illuminators">
	</div>
	<head>
		<script type="text/javascript" id="MathJax-script" async
  			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
		</script>
		<script>
  			MathJax = {
    				tex: {
      					inlineMath: [['$', '$']]
    				}
  			};
		</script>
 		<link rel="stylesheet" href="styling.css">
		<Title>Homework 3 - Pathtracer</Title>
	</head>
	<body>
		<h2>Homework 3 - <b>Pathtracer</b></h2>
		<center>
		<h5 style="color: #DBDEE1">by Sriram Srivatsan &#40;sriram.srivatsan &#40;at&#41; berkeley.edu&#41; and Jaron Erba &#40;jaronerba &#40;at&#41; berkeley.edu&#41;</h5>
		</center>
		<a style="color: #DBDEE1", href="https://cal-cs184-student.github.io/hw-webpages-sp24-ElShroomster/"> Main Page </a>

		<h3><b>Overview</b></h3>
		<p style="color: #DBDEE1; width: 100%">Hot steamy carrots </p>
		<br>
		
		<h3><b>Part 1: Ray Generation and Scene Intersection </b></h3>
		<p style="color: #DBDEE1; width: 100%">In concept, the ray generation scheme works by generating a ray (or pretty much a vector) from the camera position in world space to a specific point in camera space determined by $(x,y)$. We implement this in generate_ray() by creating a new ray with ray.min_t = nClip, ray.max_t = fClip, and ray.o = camera pos. We are then able to calculate the camera size, and thus calculate the camera relative positions of $x$ and $y$. We can then convert this point to world space, set it to the $d$ value of the ray, and return the ray.</p>
		<p style="color: #DBDEE1; width: 100%">For the randomized ray sampling within a pixel inside of raytrace_pixel(), we use  the get_sample() function to find a random position within the pixel, use generate_ray to create the ray, and then call est_radiance_globabl_illumination() on that pixel. We can then update the pixel and add it to the buffer.</p>
		<p style="color: #DBDEE1; width: 100%">For our triangle intersection, we just used a simple algorithm from the lecture slides. We first calculate $E_1$, $E_2$, $S$, $S_1$, and $S_2$  from the given ray, and then use the equation  $$\frac{1}{S_1 \bullet E_1} \cdot \left(S_2\bullet E_2, S_1\bullet S, S_2\bullet r_d\right)$$ to calculate the intersection. Then, after applying a few checks (namely, checking if the x,y, and z components are in bounds,) we are able to return true. (For intersect(), not has_intersection(), we also add the relevant values to the given intersection.)</p>
		<p style="color: #DBDEE1; width: 100%">For sphere intersection, we used the idea that a ray is determined by $r(t)=o+t\cdot d$. So, from the slides, the intersection of the ray can be found by solving at^2+bt+c-0 where $a$ is the dot product of the ray direction with itself, $b$ is twice the dot product of the ray direction with the vector from the ray origin to the sphere, and $c$ is the squared distance between the ray origin and the sphere center minus the squared radius of the sphere.</p>
		<p style="color: #DBDEE1; width: 100%">Then, we are able to determine if the ray had an intersection with the sphere based on the value of the determinant. Our code implements this quite literally. Additionally, on intersect(), not has_intersection(), we add the intersection time $t$ to the Intersection struct passed into the function.</p>
		<p style="color: #DBDEE1; width: 100%">Now we can render some pretty images as can be seen below:</p>
		<div class="row">
  			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task1/lucy.png" alt="0">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task1/cow.png" alt="1">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task1/spheres.png" alt="2">
			</div>
		</div>
		<br>
		<br>
		
		
		<h3><b>Part 2: Bounding Volume Hierarchy</b></h3>
		<p style="color: #DBDEE1; width: 100%">Our BVH construction algorithm was very simple. We would take a start and end iterator for our primitives that should be in a current node. If the primitive count is under our node threshold, we simply store the primitive iterators in our node. Otherwise, we test to see which axis to split our primitives on by finding the axis split that results in an even split of the primitives giving both sides almost even volume. We calculate this by finding the overall centroid and putting primitives on their respective sides. Then, we use the iterators to sort our sub-array and recurse with the left and right nodes being the left and right (x, y, or z) of this centroid. Normal shading for a few large dae files are shown below: </p>
		
		<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task1/task1/spheres.png" alt="2">

		<p style="color: #DBDEE1; width: 100%">We tested the rendering speeds on the files meshedit/cow.dae and meshedit/beetle.dae. The cow without the BVH took 31.7701 seconds on average, while the BVH shortened this down to .2939 seconds on average. Meanwhile, the beetle took .4954 seconds on average with the BVH while without a BVH it took 39.1173, which is quite similar in terms of ratio. If a BVH is truly O(logn) traversal whereas without the BVH acceleration is O(n) for all primitives, then we can reconstruct the number of primitives in the image, which using a calculator for gives very close results for both the cow and the beetle. Clearly, BVH is superior and no smart person should render an image without it. I wouldn't even wish it upon my worst enemy to render an image without BVH acceleration. </p>
		<br>
		<br>
		
		<h3><b>Part 3: Direct Illumination</b></h3>
		<p style="color: #DBDEE1; width: 100%">To implement the hemisphere variation for direct lighting, we simply calculated num_samples rays and then returned the average of them. To actually calculate these rays though, first we had to convert wi to world space, after which we could create a ray from hit_p to the world version of wi. Now, we had to call the intersect function on this ray. On the case of an intersection, we then added $$\text{emission}_{\text{BSDF}}\cdot f(w_{\text{out}}, wi)\cdot wi_z \cdot p$$ where p is the value we are normalizing to in the hemisphere. Also, at this point, $f$ simply returns $\frac{\text{reflectance}}{\pi}$ because we only have one type of BSDF. Unfortunately, on this part, we had a very strange bug that we were stuck on for hours. Even more unfortunate for us, it turned out to not be in this part at all, but was actually a small bug with the implementation of Part 2. </p>
		<p style="color: #DBDEE1; width: 100%">Importance sampling was a bit more difficult to implement, as we had to sample from each of the lights instead of in a hemisphere. So, we created a for loop that iterates through each light in scene->lights. Inside of this,  we first check if the light is a delta light (in this assignment it is not), and if it isnâ€™t, we just set our iterations to the variable ns_area_light.</p>
		<p style="color: #DBDEE1; width: 100%">Inside the inner loop (goes for ns_area_light iterations,) we must call sample_L() with the appropriate parameters, and then create a ray with hit_p and wi (We make sure that its min_t and max_t are exactly EPS_F off the borders.) Finally, if there is no intersection, then we use the formula $$f(w_{\text{out}}, wi)\cdot l \cdot  \frac{\text{wi} \bullet n}{\text{PDF}}$$ where $l$ is the return value of sample_L(), and PDF is the pdf attribute of sample_L() to calculate the value at that point, which we then add to our total light sum. We then return that value divided by the total number of iterations.</p>
		<p style="color: #DBDEE1; width: 100%">We can now see some results of the two algorithms. (Hemisphere; top, importance; bottom.)</p>
		<div class="row">
  			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task3/edl_hem_CBbunny.png" alt="0">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task3/edl_hem_coil.png" alt="0">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task3/edl_hem_spheres.png" alt="0">
			</div>
		</div>
		<div class="row">
  			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task3/edl_imp_CBbunny.png" alt="0">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task3/edl_imp_coil.png" alt="0">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task3/edl_imp_spheres.png" alt="0">
			</div>
		</div>
		<p style="color: #DBDEE1; width: 100%">The differences between these two are, honestly, quite obvious. We also tested light sampling, and the results were pretty interesting. 1, 4, and 16 samples were pretty similar, although 16 was starting to get a fair bit less noisy, only having unacceptable levels of noise in the shadows.</p>
		<div class="row">
  			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task3/light_comp_1_CBbunny.png" alt="0">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task3/light_comp_4_CBbunny.png" alt="0">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task3/light_comp_16_CBbunny.png" alt="0">
			</div>
		</div>
		<p style="color: #DBDEE1; width: 100%">64 samples, on the other hand, resolved most of the issues, but the slightest amount of noise can be seen in the shadow around the bunny still. Also, one interesting thing we noticed with the light sampling is that even on higher samples, the edges never get perfectly crisp as can be seen below, which seems to be a disadvantage of the technique.</p>
		<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task3/light_comp_64_CBbunny.png" alt="2" class="center">
		<br>
		<br>
		
		<h3><b>Part 4: Global Illumination</b></h3>
		<p style="color: #DBDEE1; width: 100%">Here are a few scenes rendered with global illumination with 1024 samples:</p>
		<div class="row">
  			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task4/pt1_gbl_bench.png" alt="0">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task4/pt1_gbl_bunny.png" alt="0">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task4/pt1_gbl_spheres.png" alt="0">
			</div>
		</div>
		<p style="color: #DBDEE1; width: 100%">We picked the banana scene to test direct and indirect lighting individually. The first is direct, which looks like this:</p>
		<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task4/pt2_direct_banana.png" alt="2" class="center">
		<p style="color: #DBDEE1; width: 100%">The other is indirect, which looks like this:</p>
		<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task4/pt2_indirect_banana.png" alt="2" class="center">
		<p style="color: #DBDEE1; width: 100%">Now, we rendered images with max_ray_depth set to 0, 1, 2, 3, 4, and 5, shown below in order:</p>
		<div class="row">
  			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task4/pt3_bunny_rd0.png" alt="0">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task4/pt3_bunny_rd1.png" alt="0">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task4/pt3_bunny_rd2.png" alt="0">
			</div>
		</div>
		<div class="row">
  			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task4/pt3_bunny_rd3.png" alt="0">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task4/pt3_bunny_rd4.png" alt="0">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task4/pt3_bunny_rd5.png" alt="0">
			</div>
		</div>
		<br>
		<br>
		
		<h3><b>Part 5: Adaptive Sampling</b></h3>
		<p style="color: #DBDEE1; width: 100%">Below are images of cow.dae before and after some edge splits and edge splits and flips: </p>
		<div class="row">
			<div class="column">
			  <img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task1/task1/spheres.png" alt="2">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task1/task1/spheres.png" alt="2">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task1/task1/spheres.png" alt="2">
			</div>
		</div>
		<br>
		
		<h3><b>Part 6: Extra Credit</b></h3>
		<p style="color: #DBDEE1; width: 100%">The teapot rendered after the task can be seen below:</p>
		<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw3/images/task1/task1/spheres.png" alt="2">
		<br>
		<br>
	</body>
</html>
