<html>
	<div class="container">
  		<img src="https://github.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/blob/master/hw2/images/malevolent-2.png?raw=true" alt="Malevolent Meshes">
	</div>
	<head>
		<script type="text/javascript" id="MathJax-script" async
  			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
		</script>
		<script>
  			MathJax = {
    				tex: {
      					inlineMath: [['$', '$']]
    				}
  			};
		</script>
 		<link rel="stylesheet" href="styling.css">
		<Title>Homework 2 - Geometric Modeling </Title>
	</head>
	<body>
		<h2>Homework 2 - <b>Geometric Modeling</b></h2>
		<center>
		<h5 style="color: #DBDEE1">by Sriram Srivatsan &#40;sriram.srivatsan &#40;at&#41; berkeley.edu&#41; and Jaron Erba &#40;jaronerba &#40;at&#41; berkeley.edu&#41;</h5>
		</center>
		<a style="color: #DBDEE1", href="https://cal-cs184-student.github.io/hw-webpages-sp24-ElShroomster/"> Main Page </a>

		<h3><b>Overview</b></h3>
		<p style="color: #DBDEE1; width: 100%">Homework 2 was all about geometric modeling. In Part I, we first started with drawing curves using control points using de Casteljau subdivision. Using this abstraction, we increased our dimensionality to surfaces in order to render full .bez files. </p>
		<p style="color: #DBDEE1; width: 100%"> Part II was all about meshes and mesh algorithms. First, we started off by implementing area-weighted vertex normals for Phong shading, making our teapots and other mesh structures look less square. We then implemented edge flipping and splitting which allowed us to modify our mesh in real time. Finally, we implemented upsampling of our mesh through loop suubdivision by using our edge splitting and flipping abstractions.</p>
		<p style="color: #DBDEE1; width: 100%"> Overall, the project was more fun than challenging. Unfortunately, pointers were our main issue throughout Part II, since a single bad reassignment could percolate and debugging would require us to remember each step precisely. Thankfully, we simplified this process by writing out the algorithm by hand before, giving us a reference in case anything went wrong.</p>
		<br>
		
		<h3><b>Part 1: Bezier Curves with 1D de Casteljau Subdivision</b></h3>
		<p style="color: #DBDEE1; width: 100%">De Casteljau's algorithm is decently straightforward. The idea in this function is to take a list of values: $[s_1,s_2,s_3,...s_n]$ and create a new list with $$\text{lerp}(s_1,s_2,t), \text{lerp}(s_2,s_3,t),...\text{lerp}(s_{n-1},s_n,t).$$ When repeated $n-1$ times, this will calculate one point on the bezier curve. So, to do this in C++ we simply need to create an empty vector, <b>returnvec</b>, loop through every index in the input vector, and then add each lerp to <b>returnvec</b>. To accomplish the lerp we simply use $$(1-t) * p_i + t * p_{i+1}.$$ This creates some very cool effects, as can be seen below.</p>
		<div class="row">
  			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/base.png" alt="svg4 Aliased">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/step1.png" alt="svg4 Slightly Aliased">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/step2.png" alt="svg4 Less Aliased">
			</div>
		</div>
		<div class="row">
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/step3.png" alt="svg4 Less Aliased">
			</div>
  			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/step4.png" alt="svg4 Aliased">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/step5.png" alt="svg4 Slightly Aliased">
			</div>
		</div>
		<p style="color: #DBDEE1; width: 100%">The final Bezier curve can be seen below:</p>
		<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/finalcurve2.png" alt="svg4 Less Aliased">
		<p style="color: #DBDEE1; width: 100%">Here are a few more edits to a second curve:</p>
		<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/curve2full.png" alt="svg4 Less Aliased">
		<br>
		<br>
		
		
		<h3><b>Part 2: Bezier Surfaces with Separable 1D de Casteljau</b></h3>
		<p style="color: #DBDEE1; width: 100%">    In order to reduce aliasing such as jaggies and floating pixels, we use supersampling. We set a sample rate and sample multiple evenly spaced points inside each pixel, then average them to get the total color of that pixel. This means that if a triangle has some area inside a pixel but doesn’t go through the center, we can still ensure that the figure gets equal representation. For example, if the triangle goes through the top right corner, that would be approximately 1/9 of the pixel’s area, so we would give that pixel 1/9th of the triangle’s color. Initially, we thought it would be more space efficient to keep our screen space array the same dimensions, and simply average down each pixel as we rasterize each triangle. This sounded like a great idea, but when multiple triangles were slightly in a single pixel, this prevented the final pixel color from incorporating all of the triangles involved. Instead, we got weird bright lines cutting through our images. In the end, we decided to multiply the dimensions of our screen space matrix by the sample rate, then rasterize each triangle in our svg by pretending the screen was simply much larger. To draw the matrix onto the screen, we then averaged down for each pixel. Below is an example of supersampling, using 1, 4, and 16 points inside each pixel, reducing aliasing in the same image represented above: </p>
		<br>
		
		<h3><b>Part 3: Area-Weighted Vertex Normals</b></h3>
		<p style="color: #DBDEE1; width: 100%"> To implement area weighted vertex normals, we first looped through every face that is adjacent to our vertex. After validating that our face isn't a boundary, we  then calculate the area of the triangle by using the norm of the cross product of vertex positions divided by two. This calculation helped us a lot, since otherwise having to use trignometric functions would have slowed down our code. Finally, we stored the weighted normal of each face in a Vector3D which we then squished into a unit vector at the end. This completes our algorithm. Below are screenshots of our code at work. Above is flat shading, and below is our newly implemented Phong shading: </p>

		<div class="row">
			<div class="column">
			  <img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/flat_teapot.png" alt="flat_teapot">
			</div>
			<div class="column">
				<img src="" alt="">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/phong_teapot.png" alt="phong_teapot">
			</div>
		</div>
		<p style="color: #DBDEE1; width: 100%"> This part of the assignment was not very hard and we had no issues implementing code or debugging, giving us false hope for the next three parts. </p>

		<br>
		<h3><b>Part 4: Edge Flip</b></h3>
		<p style="color: #DBDEE1; width: 100%"> </p>
		<br>
		
		<h3><b>Part 5: Edge Split</b></b></h3>
		<p style="color: #DBDEE1; width: 100%"> </p>
		<br>
		
		<h3><b>Part 6: Loop Subdivision for Mesh Upsampling</b></h3>
		<p style="color: #DBDEE1; width: 100%"> </p>
		<br>
		<br>
	</body>
</html>
