<html>
	<div class="container">
  		<img src="https://github.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/blob/master/hw2/images/malevolent-2.png?raw=true" alt="Malevolent Meshes">
	</div>
	<head>
		<script type="text/javascript" id="MathJax-script" async
  			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
		</script>
		<script>
  			MathJax = {
    				tex: {
      					inlineMath: [['$', '$']]
    				}
  			};
		</script>
 		<link rel="stylesheet" href="styling.css">
		<Title>Homework 2 - Geometric Modeling </Title>
	</head>
	<body>
		<h2>Homework 2 - <b>Geometric Modeling</b></h2>
		<center>
		<h5 style="color: #DBDEE1">by Sriram Srivatsan &#40;sriram.srivatsan &#40;at&#41; berkeley.edu&#41; and Jaron Erba &#40;jaronerba &#40;at&#41; berkeley.edu&#41;</h5>
		</center>
		<a style="color: #DBDEE1", href="https://cal-cs184-student.github.io/hw-webpages-sp24-ElShroomster/"> Main Page </a>

		<h3><b>Overview</b></h3>
		<p style="color: #DBDEE1; width: 100%">Homework 2 was all about geometric modeling. In Part I, we first started with drawing curves using control points using de Casteljau subdivision. Using this abstraction, we increased our dimensionality to surfaces in order to render full .bez files. </p>
		<p style="color: #DBDEE1; width: 100%"> Part II was all about meshes and mesh algorithms. First, we started off by implementing area-weighted vertex normals for Phong shading, making our teapots and other mesh structures look less square. We then implemented edge flipping and splitting which allowed us to modify our mesh in real time. Finally, we implemented upsampling of our mesh through loop suubdivision by using our edge splitting and flipping abstractions.</p>
		<p style="color: #DBDEE1; width: 100%"> Overall, the project was more fun than challenging. Unfortunately, pointers were our main issue throughout Part II, since a single bad reassignment could percolate and debugging would require us to remember each step precisely. Thankfully, we simplified this process by writing out the algorithm by hand before, giving us a reference in case anything went wrong.</p>
		<br>
		
		<h3><b>Part 1: Bezier Curves with 1D de Casteljau Subdivision</b></h3>
		<p style="color: #DBDEE1; width: 100%">De Casteljau's algorithm is decently straightforward. The idea in this function is to take a list of values: $[s_1,s_2,s_3,...s_n]$ and create a new list with $$\text{lerp}(s_1,s_2,t), \text{lerp}(s_2,s_3,t),...\text{lerp}(s_{n-1},s_n,t).$$ When repeated $n-1$ times, this will calculate one point on the bezier curve. So, to do this in C++ we simply need to create an empty vector, <b>returnvec</b>, loop through every index in the input vector, and then add each lerp to <b>returnvec</b>. To accomplish the lerp we simply use $$(1-t) * p_i + t * p_{i+1}.$$ This creates some very cool effects, as can be seen below.</p>
		<div class="row">
  			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/base.png" alt="0">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/step1.png" alt="1">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/step2.png" alt="2">
			</div>
		</div>
		<div class="row">
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/step3.png" alt="3">
			</div>
  			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/step4.png" alt="4">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/step5.png" alt="5">
			</div>
		</div>
		<p style="color: #DBDEE1; width: 100%">The final Bezier curve can be seen below:</p>
		<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/finalcurve2.png" alt="finalcurve2">
		<p style="color: #DBDEE1; width: 100%">Here are a few more edits to a second curve:</p>
		<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/curve2full.png" alt="curve2full">
		<br>
		<br>
		
		
		<h3><b>Part 2: Bezier Surfaces with Separable 1D de Casteljau</b></h3>
		<p style="color: #DBDEE1; width: 100%">    In order to reduce aliasing such as jaggies and floating pixels, we use supersampling. We set a sample rate and sample multiple evenly spaced points inside each pixel, then average them to get the total color of that pixel. This means that if a triangle has some area inside a pixel but doesn’t go through the center, we can still ensure that the figure gets equal representation. For example, if the triangle goes through the top right corner, that would be approximately 1/9 of the pixel’s area, so we would give that pixel 1/9th of the triangle’s color. Initially, we thought it would be more space efficient to keep our screen space array the same dimensions, and simply average down each pixel as we rasterize each triangle. This sounded like a great idea, but when multiple triangles were slightly in a single pixel, this prevented the final pixel color from incorporating all of the triangles involved. Instead, we got weird bright lines cutting through our images. In the end, we decided to multiply the dimensions of our screen space matrix by the sample rate, then rasterize each triangle in our svg by pretending the screen was simply much larger. To draw the matrix onto the screen, we then averaged down for each pixel. Below is an example of supersampling, using 1, 4, and 16 points inside each pixel, reducing aliasing in the same image represented above: </p>
		<br>
		
		<h3><b>Part 3: Area-Weighted Vertex Normals</b></h3>
		<p style="color: #DBDEE1; width: 100%"> To implement area weighted vertex normals, we first looped through every face that is adjacent to our vertex. After validating that our face isn't a boundary, we  then calculate the area of the triangle by using the norm of the cross product of vertex positions divided by two. This calculation helped us a lot, since otherwise having to use trignometric functions would have slowed down our code. Finally, we stored the weighted normal of each face in a Vector3D which we then squished into a unit vector at the end. This completes our algorithm. Below are screenshots of our code at work. Above is flat shading, and below is our newly implemented Phong shading: </p>

		<div class="row">
			<div class="column">
			  <img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/flat_teapot.png" alt="flat_teapot">
			</div>
			<div class="column">
				<img src="" alt="">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/phong_teapot.png" alt="phong_teapot">
			</div>
		</div>
		<p style="color: #DBDEE1; width: 100%"> This part of the assignment was not very hard and we had no issues implementing code or debugging, giving us false hope for the next three parts. </p>

		<br>
		<h3><b>Part 4: Edge Flip</b></h3>
		<p style="color: #DBDEE1; width: 100%"> To implement edge flips, we simply had to reassign the pointers of each edge's vertices to the pointers of edge vertices one halfedge away, right? Wrong. There are WAY too many pointers here to even think about doint that. First, we ignore all boundary edges by using the isBoundary() function. For each vertex, we first update the halfedge pointer to the new one after flipping. Then, we modify the neighbors of each halfedge using setNeighbors and set the new face, edge, vertex, next, and twin pointers for each half edge. Finally, we set the face and edge pointers so that every single pointer is reassigned properly. Thankfully, we drew out the algorithm by hand before we implemented it, so we had no issues with pointer reassignment in this step. Unfortunately, we had issues with our naming convention, since our drawing and our variable names did not match, so we had to have a mental map of drawn edge/halfedge/vertex to variable name, which made the coding process very long and tedious. Looking back, we are so glad that this part of the assignment didn't give us any issues in terms of debugging. Below are screenshots of quadball before and after a couple flips: </p>
		<div class="row">
			<div class="column">
			  <img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/quadball_normal.png" alt="quadball_normal">
			</div>
			<div class="column">
				<img src="" alt="">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/quadball_flipped.png" alt="quadball_flipped">
			</div>
		</div>
		<br>
		
		<h3><b>Part 5: Edge Split</b></b></h3>
		<p style="color: #DBDEE1; width: 100%"> Implementing edge splits was not too hard after we looked through the precise ordering of the algorithm. First, we ignored all boundary edges. We then created 6 new halfedges, 2 new faces, 1 new vertex, and 3 new edges to represent this edge split. Then, according to a diagram we drew (and labeled as improvement from task 4), we copied over some code from the previous task and assigned the pointers correctly. In terms of debugging, we had one issue that we could not figure out for a really long time with assigning isNew to the new edges/vertex. We were assigning isNew at the top of the function, but thankfully and Ed poster mentioned that you cannot do this until the end, which saved us from going insane trying to debug this issue. Also, we had some issues with assigning pointers correctly, since we used code from task 4 without realizing that pointer assignment for edge flips and edge splits are greatly different.</p>
		<p style="color: #DBDEE1; width: 100%"> Below are images of cow.dae before and after some edge splits and edge splits and flips: </p>
		<div class="row">
			<div class="column">
			  <img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/cow_normal.png" alt="cow_normal">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/cow_split.png" alt="cow_split">
			</div>
			<div class="column">
				<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/hw2/images/cow_split_and_flipped.png" alt="cow_split_and_flipped">
			</div>
		</div>
		<br>
		
		<h3><b>Part 6: Loop Subdivision for Mesh Upsampling</b></h3>
		<p style="color: #DBDEE1; width: 100%"> </p>
		<br>
	</body>
</html>
