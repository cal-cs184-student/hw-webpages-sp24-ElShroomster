<html> 
	<div class="container">
  		<img src="https://raw.githubusercontent.com/cal-cs184-student/hw-webpages-sp24-ElShroomster/master/cs184writups.png" alt="Ingenious Illuminators">
	</div>
	<head>
		<script type="text/javascript" id="MathJax-script" async
  			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
		</script>
		<script>
  			MathJax = {
    				tex: {
      					inlineMath: [['$', '$']]
    				}
  			};
		</script>
 		<Title>Sriram Srivatsan CS184 Pages</Title>
 		<link rel="stylesheet" href="styling.css">
		
		<style>
		a:link, a:visited {
		  background-color: #DBDEE1;
		  color: #17191A;
		  padding: 14px 25px;
		  text-align: center;
		  text-decoration: none;
		  display: inline-block;
		}
		
		a:hover, a:active {
		  background-color: white;
		}
		</style>

	</head>
	<body>
		<h2>CS 184 Writeups</b></h2>
		<center>
		<h5 style="color: #DBDEE1">by Sriram Srivatsan &#40;sriram.srivatsan &#40;at&#41; berkeley.edu&#41; and Jaron Erba &#40;jaronerba &#40;at&#41; berkeley.edu&#41;</h5>
		</center>
		<br>
		<h3><b>Homework 1 - Rasterizer</b></h3>
		
		<a href="/hw1/index.html"><b>Homework 1 - Rasterizer</b></a>
		<p style="color: #DBDEE1; width: 100%">Homework 3 was a delightful trip into the world of pathtracers and global illumination. In Part I, we started out by generating rays and writing the necessary intersections to render our first image that used the surface normals. Part II was perhaps the most interesting section of the project, since with an edit to how we organized the BVH tree (That is, using surface area instead of the median), we were able to radically speed up our code, which was cause for great excitement.</p>
		<p style="color: #DBDEE1; width: 100%">Now, armed with our ability to quickly render scenes, we took on Part III. Most of the tasks could be implemented using formulas from the lecture slides, but this part turned out to be a little more than we bargained for, as it took us much longer than expected. We had trouble finding a bug within the section, which ended up making sense, since it wasnâ€™t in that task the whole time. A bug in the collisions in Part II had caused us all the issues in Part III. Lesson learned: Always check old code. Other than that, this section was quite interesting once we got it working, because we finally got to see the shadows on the bunny and the floor.</p>
		<p style="color: #DBDEE1; width: 100%">Part IV produced some stunning images that surpassed our expectations. With only writing one other recursive function, we were able to expand the number of light bounces, creating the delightful, soft look of global illumination. We were also able to see exactly how increasing the number of light bounces affected the image.</p>
		<p style="color: #DBDEE1; width: 100%">Part V was also pretty neat, since it enabled us to see how adaptive sampling actually rendered the image. We simply had to write a new function to count how many samples the est_radiance_global_illumination() function returned. It was nice to see a visual representation of what we already assumed to be true: The areas in more shadow take longer to converge, and the ones in light converge quicker. </p>
		<br><br><br>
		<h3><b>Homework 2 - Meshes</b></h3>
		<p style="color: #DBDEE1; width: 100%">Homework 2 was all about geometric modeling. In Part I, we first started with drawing curves using control points using de Casteljau subdivision. Using this abstraction, we increased our dimensionality to surfaces in order to render full .bez files. </p>
		<p style="color: #DBDEE1; width: 100%">Part II was all about meshes and mesh algorithms. First, we started off by implementing area-weighted vertex normals for Phong shading, making our teapots and other mesh structures look less square. We then implemented edge flipping and splitting which allowed us to modify our mesh in real time. Finally, we implemented upsampling of our mesh through loop subdivision by using our edge splitting and flipping abstractions.</p>
		<p style="color: #DBDEE1; width: 100%">Overall, the project was more fun than challenging. Unfortunately, pointers were our main issue throughout Part II, since a single bad reassignment could percolate, and debugging would require us to remember each step precisely. Thankfully, we simplified this process by writing out the algorithm by hand before we even started coding, which gave us something to reference in case anything went wrong.</p>
		<a href="/hw2/index.html"><b>Homework 2 - Meshes</b></a>
		<br><br><br>
		<h3><b>Homework 3 - Pathtracer</b></h3>
		<p style="color: #DBDEE1; width: 100%">Homework 2 was all about geometric modeling. In Part I, we first started with drawing curves using control points using de Casteljau subdivision. Using this abstraction, we increased our dimensionality to surfaces in order to render full .bez files. </p>
		<a href="/hw3/index.html">><b>Homework 3 - Pathtracer</b>r</a>
		<br><br><br>
		<h3><b>Homework 4 - Unknown</b></h3>
		<p style="color: #DBDEE1; width: 100%">Homework 2 was all about geometric modeling. In Part I, we first started with drawing curves using control points using de Casteljau subdivision. Using this abstraction, we increased our dimensionality to surfaces in order to render full .bez files. </p>
		<a href="/hw4/index.html">><b>Homework 4 - Unknown</b></a>
	</body>
	<script>
		var links = document.body.getElementsByTagName("a")
		var a = window.location.href.indexOf(".io")
		var repo_name = window.location.href.substring(a+3)
		for(var i = 0; i < links.length; i++){
			var link = links[i]
			var actual_name = link.href.substring(link.href.indexOf(".io")+4)
			link.href = repo_name + actual_name
		}
	</script>
</html>
